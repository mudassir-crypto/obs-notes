##### ORM
![[jpa1.jpg]]

ORM is a technique that lets us interact with a database using objects in programming language instead of writing raw SQL.

It automatically maps database tables → to classes, and rows → to objects.

One liner: "ORM is a way to map Java objects to database tables so that developers can work with objects instead of SQL queries. Hibernate is a popular ORM framework in Java."

Example:  
Without ORM:
```sql
SELECT * FROM users WHERE id = 1;
```

With ORM (in Java using JPA/Hibernate):
```java
User user = userRepository.findById(1L).get();
```

![[jpa2.jpg]]

JPA is a specification — it defines how Java objects should map to database tables, but it doesn’t provide the actual implementation. Hibernate is one of the most popular implementations of JPA. In other words, JPA is the set of rules, and Hibernate is the tool that follows those rules to do the actual work.

JPA → Interface / Specification (What to do)
Hibernate → Implementation / Tool (How to do it)


![[jpa3.jpg]]


* `spring.jpa.hibernate.ddl-auto`
configures how Hibernate handles the database schema
![[jpa4.jpg]]


User entitity:
```java
@Entity
@Table(name = "USER")
public class User {

	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	@Column(name = "USER_ID")
	private int id;

	@Column(name = "USERNAME")
	private String name;

	@Column(name = "CITY", length = 50)
	private String city;

	@Column(name = "AGE", length = 2)
	private int age;

	public User(int id, String name, String city, int age) {
		super();
		this.id = id;
		this.name = name;
		this.city = city;
		this.age = age;
	}
	public User() {
		super();
		// TODO Auto-generated constructor stub
	}
	public int getId() {
		return id;
	}
	public void setId(int id) {
		this.id = id;
	}
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getCity() {
		return city;
	}
	public void setCity(String city) {
		this.city = city;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
	@Override
	public String toString() {
		return "User [id=" + id + ", name=" + name + ", city=" + city + ", age=" + age + "]";
	}
}

```

User repository:
```java
@Repository
public interface UserRepository extends JpaRepository<User, Integer>{ 
}
```

User ServiceImpl:
```java
@Service
public class UserServiceImpl implements UserService {

	Logger logger = LoggerFactory.getLogger(UserServiceImpl.class);

	@Autowired
	private UserRepository userRepository;

	@Override
	public User saveUser(User user) {
		User savedUser = this.userRepository.save(user);
		logger.info("User saved: {}", savedUser.getId());
		return savedUser;
	}

	@Override
	public User updateUser(User user, int userId) {
		User existingUser = this.userRepository.findById(userId).orElseThrow(() -> new RuntimeException("User not found"));
		
		existingUser.setName(user.getName());
		existingUser.setAge(user.getAge());
		existingUser.setCity(user.getCity());
		User addedUser = this.userRepository.save(existingUser);
		
		return addedUser;
	}

	@Override
	public void deleteUser(int userId) {
		User existingUser = this.userRepository.findById(userId).orElseThrow(() -> new RuntimeException("User not found"));
		this.userRepository.delete(existingUser);

	}

	@Override
	public User getUser(int userId) {
		User user = this.userRepository.findById(userId).orElseThrow(() -> new RuntimeException("User not found"));
		logger.info("Got user: {}", user.getId());
		return user;
	}

	@Override
	public List<User> getAllUsers() {
		List<User> users = this.userRepository.findAll();
		return users;
	}
}
```

##### One To One:

```java
@Entity
@Table(name = "jpa_students")
public class Student {

	@Id
	private int student_id;
	private String name;
	
	@OneToOne(mappedBy = "student", cascade = CascadeType.ALL)
	private Laptop laptop;
	
}
```

```java
@Entity
@Table(name = "jpa_laptops")
public class Laptop {
	@Id
	private int laptop_id;
	private String modelNumber;
	private String brand;
	
	@OneToOne
	@JoinColumn(name = "student_id") //column stays as this name instead of autogen name
	private Student student;
}
```
![[jpa5.jpg]]
![[jpa6.jpg]]

CommandLineRunner: 
```java
//		OneToOne mapping
	Student student1 = new Student();
	student1.setName("Ankur tiwari");
	student1.setStudent_id(13);

	Laptop laptop1 = new Laptop();
	laptop1.setLaptop_id(1287);
	laptop1.setBrand("Acer");
	laptop1.setModelNumber("ANS-2233");

	laptop1.setStudent(student1);
	student1.setLaptop(laptop1);

	Student savedUser = this.studentRepository.save(student1);
	logger.info(savedUser.getName());
		
	// on saving student, laptop is not getting saved
	// 1st: save laptop manually
	// else use cascade in entity
```


##### One To Many:
```java
@Entity
@Table(name = "jpa_students")
public class Student {

	@Id
	private int student_id;
	private String name;
	
	@OneToOne(mappedBy = "student", cascade = CascadeType.ALL)
	private Laptop laptop;
	
	@OneToMany(mappedBy = "student", cascade = CascadeType.ALL)
	private List<Address> addressList = new ArrayList<>();
}
```
```java
@Entity
@Table(name = "jpa_address")
public class Address {

	@Id
	private int address_id;

	private String street;
	private String city;
	private String country;
	
	@ManyToOne
	@JoinColumn(name = "student_id")
	private Student student;
}
```
![[jpa5.jpg]]
![[jpa7.jpg]]

CommandLineRunner:
```java
//	OneToMany
	Student student2 = new Student();
	student2.setName("Jayesh Shukla");
	student2.setStudent_id(345);
		
	Address a1 = new Address(233, "235/543", "LKO", "IND", student2);
	Address a2 = new Address(234, "45/232", "MUM", "IND", student2);
		
	List<Address> addressList = new ArrayList<>();
	addressList.add(a1);
	addressList.add(a2);
		
	student2.setAddressList(addressList);
	this.studentRepository.save(student2);
		
	logger.info("Student added with address with city {}, {}", a1.getCity(), a2.getCity());
		
```

##### Many to Many
```java
@Entity
@Table(name = "jpa_category")
public class Category {
	
	@Id
	private int cId;
	private String title;
	
	@ManyToMany(mappedBy = "categories", cascade = CascadeType.ALL, fetch = FetchType.EAGER)
	private List<Product> products = new ArrayList<>();
}
```
```java
@Entity
@Table(name = "jpa_product")
public class Product {

	@Id
	private int pId;
	private String name;
	
	@ManyToMany(fetch = FetchType.EAGER)
	private List<Category> categories = new ArrayList<>();
}
```

CommandlineRunner:
```java
	Product p1 = new Product();
	p1.setpId(1);
	p1.setName("Iphone 16 pro");

	Product p2 = new Product();
	p2.setpId(2);
	p2.setName("Samsung s24");

	Product p3 = new Product();
	p3.setpId(3);
	p3.setName("Samsung TV");

	Category c1 = new Category();
	c1.setcId(12);
	c1.setTitle("Electronics");

	Category c2 = new Category();
	c2.setcId(22);
	c2.setTitle("Mobiles");

	p1.getCategories().add(c1);
	p1.getCategories().add(c2);

	p2.getCategories().add(c1);
	p2.getCategories().add(c2);

	p3.getCategories().add(c1);
		
	this.categoryRepository.save(c1);
	this.categoryRepository.save(c2);

	this.productRepository.save(p1);
	this.productRepository.save(p2);
	this.productRepository.save(p3);
		
	Category category1 = this.categoryRepository.findById(12).get();
	logger.info("product size in category 1: {}", category1.getProducts().size());
		
	Category category2 = this.categoryRepository.findById(22).get();
	logger.info("product size in category 2: {}", category2.getProducts().size());
	
	Product product1 = this.productRepository.findById(1).get();
	logger.info("category size in product 1: {}", product1.getCategories().size());
```
![[jpa8.jpg]]
![[jpa9.jpg]]
![[jpa10.jpg]]

Example of Many To Many but we have the flexibility to set table name, column name for generated table:
```java
@Entity
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToMany(cascade = CascadeType.ALL) // Cascade all operations
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private Set<Course> courses = new HashSet<>(); // Initialize to avoid NullPointerException
}

@Entity
public class Course {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToMany(mappedBy = "courses", cascade = CascadeType.ALL) // Cascade all operations
    private Set<Student> students = new HashSet<>(); // Initialize to avoid NullPointerException
}

```

![[jpa11.jpg]]

##### Custom Finder methods

```java
Product findByProductName(String productName);
Product findByPId(int pid);
// Product findByProductNameIs(String productName);
// Product findByProductNameEquals(String productName);
Product findByProductNameIsNot(String productName);
List<Product> findByProductNameIsNull();

List<Product> findByActiveTrue();
List<Product> findByActiveFalse();

List<Product> findByProductNameStartingWith(String prefix);
List<Product> findByProductNameEndingWith(String suffix);
List<Product> findByProductNameContaining(String infix);

String pattern = "Samsung%";
List<Product> findByProductNameLike(pattern);

List<Product> findByPriceLessThan(double price);
List<Product> findByPriceLessThanEqual(double price);
List<Product> findByPriceGreaterThan(double price);
List<Product> findByPriceGreaterEqual(double price);

List<Product> findByProductNameIn(Collection<String> names);
List<Product> findByPriceBetween(Double minPrice, Double maxPrice);

List<Product> findByProductNameAndPrice(String productName, Double price);
List<Product> findByProductNameOrPrice(String productName, Double price);

List<Product> findByProductNameOrderByProductNameAsc(String productName);
List<Product> findByProductNameOrderByProductNameDesc(String productName);
```